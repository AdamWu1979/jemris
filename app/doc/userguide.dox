/**
* \mainpage 
* \section ug User-Guide:
A short <a href="userguide.html">User-Guide</a> to Jemris

* 
*/   


/**
* \page userguide User Guide 
* \section toc Table of Content
* \li <a href="ug_install.html">Installation</a>
* \li <a href="ug_intro.html">Introduction</a>
* \li <a href="ug_JEMRIS_seq.html">The %Sequence development tool \c JEMRIS_seq </a>
* \li <a href="ug_JEMRIS_sim.html">The MRI %Simulator GUI \c JEMRIS_sim </a>
* \li <a href="ug_JEMRIS_tut.html">%First steps tutorial</a>
*/

/**
**************************************************
* \page ug_install Installation
\section ug_install_pre Prerequisites
JEMRIS relies on three libraries, which need to be downloaded and installed prior to its compilation:
\li Xerces-C++ XML Parser (Version 2.8) [http://xerces.apache.org/xerces-c]
\li CLN, CLass library for Numbers [http://www.ginac.de/CLN]
\li GiNaC library for symbolic mathematics: [http://www.ginac.de]

The developers of Xerces provide precompiled packages for a variety of
operating systems. CLN as well as GiNAC need to be compiled and
installed. If you are using a debian flavour, such as ubuntu, you will
find precompiled packages for your linux in the according
repositories. The installation then is straightforward:

\li \c <b>"# sudo aptitude install libxerces28-dev"</b>
\li \c <b>"# sudo aptitude install libcln-dev"</b>
\li \c <b>"# sudo aptitude install libginac-dev"</b>

The provided version numbers for your flavor may differ. The above
will install Xerces libraries version 2.8 and GiNAC version 1.4.

\section ug_install_mpi Install MPICH if desired

Should you want to exploit more than one CPU core, you will need an
implementation of MPI. JEMRIS has been throughly tested with the MPICH
implementation. [http://www.mcs.anl.gov/research/projects/mpich2/]
MPICH is developed at the Mathematical and Computer Science division
of the Argonne Laboratories. 

You may download and compile MPICH for C++ and C. Good luck here;
The MPICH configuration steps prior to compilation ar rather not
trivial. If you use a ubuntu flavor once again the installation is very
simple: 

\li <b>\c # \c sudo \c aptitude \c install \c mpich-bin</b>
\li <b>\c # \c sudo \c aptitude \c install \c libmpich1.0gf</b>
\li <b>\c # \c sudo \c aptitude \c install \c libmpich1.0-dev</b>

Again version numbers may differ for your particular installation
depending on distribution and version.

\section ug_install_compilation Compile JEMRIS 2

Download the jemris package from [http://www.jemris.org/jemris/jemris-2.0.tgz]

The unpacked tar ball will contain two directories: libs and app. The
next step is to descend in libs/RNG and build it. RNG is a random
number generator used in some modules of JEMRIS. 

\li \c <b>"# cd jemris-2.0"</b>
\li \c <b>"# cd libs/RNG"</b>
\li \c <b>"# make"</b>

Now leave the RNG directory and compile the variable time stepping
solver CVODE developed at the Lawrence Livermore National Libraries.

\li \c <b>"# cd ../CVODE"</b>
\li \c <b>"# make"</b>

The third library of which parts are used is the Boost C++
library. This library consists only of headers and needs not to be
compiled. The next step is to build JEMRIS:

\li \c <b>"# cd ../../app/src"</b>
\li \c <b>"# make"</b>

After successful compilation you will find three binaries.

\li <b>jemris</b>: Sequential simulator and validator for the XML files for
sequences and coils.
\li <b>pjemris</b>: Parallel simulator (requires a working MPI implementation)
\li <b>sanityck</b>: Sanity check for the functionality of jemris and pjemris.

To run the sanity check, execute 

\li \c <b>"# make check"</b>

This will test the creation and the simulation of several MRI sequences which are located
in the directory \c <b>"app/xmpl"</b>

If you have made it so far, you have succeeded in compiling JEMRIS. 

\section ug_install_matlab Running JEMRIS from Matlab

Finally, to run JEMRIS  from Matlab, add the path
 
\li \c <b>"<cwd>/jemris-2.0/app/matlab"</b>

to your Matlab search path, where \c <b>"<cwd>"</b> denotes the directory in which
you extracted the archive.

Now you may run the Matlab GUIs for sequence design, coil layout, and simulation
(see \ref ug_JEMRIS_seq and \ref ug_JEMRIS_sim).

Here, you may start by loading one of the example sequences in the directory \c <b>"app/xmpl"</b>.

back to \ref toc.
**************************************************
*/


/**
**************************************************
* \page ug_intro Introduction

The Jülich environment for MRI simulations
(JEMRIS) provides functionality for the design and the experimental
numerical simulation of MRI sequences. The framework utilizes high
performance computing on parallel processor architectures, since MR
simulations of realistically sized spin ensembles are time consuming.

This manual intends to give a hands-on introduction to the software.
A comprehensive software manual to JEMRIS does not yet exist. Every
user is wellcome to start writing.

\section ug_intro_mod Mode of action: 
During the simulation the Sequence returns values of all 5 pulse-axes
(RF magnitude and phase, and 3 gradient axes) at any desired time
point to the Model, which numerically solves the Bloch equation
individually for each spin. The spins and their physical properties
(position and \f$ M_0,T_1,T_2,CS \f$) are defined by the Sample. The
Model sums up the net magnetization (\f$ M_x,M_y,M_z \f$) and stores
the resulting Signal at every desired time point of the sequence.

3D simulations are very time consuming, however, for many purposes 2D
simulation are sufficient. Here, sample properties only depend on two
spatial coordinates and, thus, the sequence only needs to encode the
spatial information along these two directions with gradients. The
rest of this documentation mostly treats the case of 2D
simulations, since these examples may be easily simulated also on
single core hardware. Therefore, no slice selection gradients will be
considered. The excitation is always performed with non-selective RF
pulses, i.e. the complete 2D sample ("the slice") will be
excited. Then, x- and y-gradients encode the MR image exactly in the
same way as it is the case in real MRI experiments after slice
selective excitation. But, of course, the simulator is able to
simulate 3D experiments.


\section ug_intro_seq The MRI Sequence: 
In the framework, the sequence is given by a set of instructions
written in XML. The XML file is automatically parsed into a set of
interacting C++ objects. Thus, sequence development is reduced to
writing the XML file, which might be seen as a scripting language for
MRI sequence development.

However, the user does not need to edit or create the XML files for the
simulation, the sequences, or the coils. MATLAB GUIs are provided with
this project, which reduce the tasks of preparation and conduction of
experiments to the actual design of the setup.

The MRI sequence is a tree structure sub-divided in two basic parts
 for sequence-loops and the actual execution of RF and gradient pulses.
 They are called ConcatSequence and AtomicSequence. The first of
 which is a container which holds other Sequences (either Atomic
 or Concat) in a defined order. This composition of subsequences
 can be repeated, defined by the loop properties of the ConcatSequence.
 The AtomicSequence plays out the pulses. It has therefore functionality
 to play out pulses of various types i.e. RF or gradients. Finally the
 DelayAtomicSequence can be used to define delays (e.g. TE,TR) between
 individual pulses in a very convenient fashion.

The next chapters explains how to design MRI sequences using
the \ref ug_JEMRIS_seq and then finally how to invoke the MRI
simulation with the \ref ug_JEMRIS_sim.

back to \ref toc.
***************************************************
*/


/**
***************************************************
* \page ug_JEMRIS_seq %Sequence development tool JEMRIS_seq

Sections:
\li \ref ug_JEMRIS_seq_treestruct
\li \ref ug_JEMRIS_seq_intro
\li \ref ug_JEMRIS_seq_modules
\li \ref ug_JEMRIS_seq_ginac

\section ug_JEMRIS_seq_treestruct The Sequence tree 

The MRI %sequence is specified utilizing a tree structure. As a simple
        %example, the EPI %sequence is now explained in terms of such
        %a tree structure to understand how and why such a structure
        %is well suited to represent an MRI %sequence.   
The first figure depicts the pulse diagram of a basic EPI sequence,
where the complete measurement is repeated two times:

\image html doc/pics/epi_puls_seq.jpg "EPI pulse sequence" 
\image latex doc/pics/epi_puls_seq.eps "EPI pulse sequence" width=4cm
Schematically, this diagram might be sketched in the following way:
\image html doc/pics/epi_loop.jpg   
\image latex doc/pics/epi_loop.eps  
Here, the modules for different RF and gradient pulses, as well as the inserted fill times to
reach correct echo time and repetition time, are given by blue squares, whereas the
repetition of these modules take place in a nested loop structure (red brackets).

Equivalently, this diagram might be drawn as a left-right ordered tree, which is very
suitable and efficient for computer-aided design and access of the pulse sequence:
\image html doc/pics/epi_treestruct.jpg
\image latex doc/pics/epi_treestruct.eps

The MRI %simulator JEMRIS utilizes such a tree structure to represent the MRI %sequence. The MatLab tool JEMRIS_seq is used to design the %sequences.

\n 

\section ug_JEMRIS_seq_intro Introduction to the sequence GUI JEMRIS_seq
Before starting the %sequence GUI, the directory in which the JEMRIS_seq.m file is located has to be added to the MatLab path-variable (use e.g. <I> "addpath('<directoryname>')" </I>). Then change to the directory in which the %sequence xml-files are located and type \c JEMRIS_seq to start the %sequence GUI.
The following picture shows a screenshot of the GUI with the EPI sequence loaded into it: 

\image html doc/pics/epi_jemris_screenshot.png 
\image latex doc/pics/epi_jemris_screenshot.eps 

The Sequence GUI allows to interactively build the sequence tree. The
tools for this are given in the top panel. The <b>"File"</b> dialog
allows to load and save sequences (XML format). The <b>"write XML"</b>
button overwrites the current sequence file according to the changes
made.

Further, this button executes a run through the sequence and draws the
sequence diagram.  Possible error output during sequence execution is
thrown to the <b>"jemris tree dump"</b> at the bottom. Instead, the
<b>"read XML"</b> button discards all changes made to the sequence
tree and rereads the current sequence from its XML file. To view the
sequence diagram, i.e. the ADC, RF, and gradient events, use the
<b>"Sequence Diagram"</b> check box. There are several features to
visualize the %sequence diagram:

\li The <b>"interval [ms]"</b> dialog changes the time axis for all pulses, whereas the
<b>"zoom"</b> button allows to interactively zoom into a specific axis.
\image html doc/pics/epi_jemsdg_screenshot.png 
\image latex doc/pics/epi_jemsdg_screenshot.eps 

\li The <b>"draw moment"</b> flag draws the gradient moments, i.e. the time integral along
the gradient axes, instead of the gradient waveforms. The moment is set to zero
after each RF pulse, however, it is inverted for 180° pulses. Thus, it shows the
correct k-space position encoding for gradient echo and spin echo sequences. 
\image html doc/pics/epi_jemsmo_screenshot.png 
\image latex doc/pics/epi_jemsmo_screenshot.eps 

\li A different view of the gradient moments is given by switching the <b>"k-space
trajectory" </b> flag: it draws the k-space trajectory. Once it is
drawn, it is possible to further add the ADC events to this plot by
another check box or have a look at the travelling order by the
activation of the <b>''Continous''</b> flag.
\image html doc/pics/epi_jemksp_screenshot.png 
\image latex doc/pics/epi_jemksp_screenshot.eps 

By clicking on a module, its individual attributes are displayed in
the upper half of the GUI and may be edited. The attribute values can
not only be actual numbers, analytical expressions are also accepted
(see section \ref ug_JEMRIS_seq_ginac ).  Often attribute values from
other modules are needed for an analytical expression, e.g. the area
under a previous gradient pulse or the duration of a previous
pulse. This is handled using the <b>"observe"</b> attribute (see also
section \ref ug_JEMRIS_seq_ginac ).

\n 

\section  ug_JEMRIS_seq_modules Sequence Building Modules
This section briefly summarizes all %sequence building modules and its attributes.
The interaction of these modules is explained in the next section \ref ug_JEMRIS_seq_ginac.

\subsection ug_JEMRIS_seq_intro_para The Parameters Module
The parameter module (orange circle) is always present in a %sequence. It is not a part of the sequence tree but exists only once. The module 
contains global attributes such as field of view \f$ FOV_{x/y/z} \f$, the size of the image matrix, the gradient slew rate etc.

\subsection ug_JEMRIS_seq_intro_seqmod Sequence Modules
So far, there exist three different modules which are of type sequence:
<ul>
    <li> The  <b> ConcatSequence </b> module (yellow circle) represents a loop which can be controlled by its attribute "repetitions"
         (default value is 1). It may contain other ConcatSequences, AtomicSequences or DelayAtomicSequences, but no pulses.
         A ConcatSequence also has \ref ug_JEMRIS_seq_ginac_hidden, which are not set by the user but in runtime:
	 <ol>
		<li> "Counter" is the loop counter through which other modules get information of the current value of the loop counter.
		<li> "Duration" specifies the duration of the ConcatSequence, which of course depends on the duration of its children.
	 </ol>
	 Additionally, the attributes \c "aux1,aux2,aux3" define  auxiliary
         variables. These values are not used in the calculation of the ConcatSequence. However they can be observed by other modules,
         thus lengthy expressions can be displayed in a more structured way.

    <li> The <b> AtomicSequence </b> module (purple circles) contains the actual pulses. Each AtomicSequence can contain multiple
         pulses which are then applied simultaneously.  Additionally, the attributes \c "Inclination", \c "Azimut", \c "RotAngle" define
         the rotation matrix for gradient pulses inside this AtomicSequence, e.g. for oblique slices or radial imaging.
         As the ConcatSequence, the AtomicSequence has auxiliary attributes for convenience, and a hidden attribute specifying its
	 duration.

    <li> The <b> DelayAtomicSequence </b> (green circles) is a specialised AtomicSequence to define delays.
         It can either be defined as a simple delay by setting the parameter:  \c "delay = 30", which will simple wait for 30ms.
         However, for e.g. a echo time delay, the echo time is defined from the center of "A_RF" to the center of "A_G_RO".
         The needed dead-time is TE minus the duration of "A_G_DP" and half the durations of "A_RF" and "A_G_RO". This can be
         automatically inserted by the DelayAtom. The required parameters for a TE of 30ms are then:  \c "delay = 30 ",
          \c "StartSeq = A_RF",  \c "StopSeq = A_G_RO",  \c "DelayType = C2C ".
         Apart from the "center-to-center" ( \c "C2C") delay type, following other delay types are defined:
	 <ol>
         	<li> \c "C2E" (center-to-end)
         	<li> \c "B2C" (beginning-to-center)
         	<li> \c "B2E" (beginning-to-end; default, if no delaytype is specified) 
	 </ol>
         \image html doc/pics/ug_TE_delay.jpg
         \image latex doc/pics/ug_TE_delay.eps
</ul>

\n 

\subsection ug_JEMRIS_seq_intro_pulse Pulse Shape Modules

There exist several pulses which may be inserted into an AtomicSequence. All pulses have several attributes in common:

 \li \c Duration: Every pulse has a duration, which is explicitly set. (In some cases, it is however calculated from other attributes.)

 \li \c InitialDelay: A pulse may start at a later time within the atom, e.g. an RF pulse may wait for the ramp-up time of a gradient pulse. 

 \li \c ADC: The ADCs specify the number of readout events. These events are equidistantly distributed over the length of the pulse,
        and the simulator will save the acquired signal at each of these time points. 

 \li \c Phaselock: Locks the phase of the ADCs inside the module to the phase of the last RF pulse. Can be \c 1 (true) or \c 0 (false).

The most simple pulse-shape module is the <b> \c "EmptyPulse".</b> It represents a dead-time according its specified duration in which, if ADCs
are present, simulated data is acquired. (The above introduced DelayAtomicSequence is a special implementation of an AtomicSequence which
has a single EmptyPulse as a child.)

All other pulses subdived into two main pulse classes, RF Pulses and Gradient Pulses, respectively. The following
<b> RF pulse Modules</b> are defined in JEMRIS:
<ul> 
	<li> <b> \c HardRFPulse</b>: A nonselective rectangular RF pulse. It has the following specific attributes
	 <ol>
         	<li> \c "FlipAngle" The applied flip angle
         	<li> \c "InitialPhase" The constant phase during the duration of the pulse (the rotation axis)
         	<li> \c "Channel" An optional channel number, in case of parallel RF transmit.
	 </ol>

	<li> <b> \c GaussianRFPulse</b>: A Gaussian-shaped RF pulse. It has all the attributes of the HardRFPulse, and additionally
	 <ol>
         	<li> \c "Bandwidth" The bandwidth of the Gaussian
         	<li> \c "Frequency" The frequency-shift applied for this RF pulse
	 </ol>

	<li> <b> \c SincRFPulse</b>: A sinc-shaped (\f$sin(t)/t\f$) RF pulse. It has all the attributes of the GaussianRFPulse, and additionally
	 <ol>
         	<li> \c "Zeros" The number of positive zero-crossings (or side lobes) of the sinc function (default 3)
         	<li> \c "Apodization" The apodization factor of the Hanning window (default 0.5)
	 </ol>

	<li> <b> \c AnalyticRFPulse</b>: An arbitrary RF pulse specified through an analytic expression. It has all the attributes of the
		GaussianRFPulse, and additionally
	 <ol>
         	<li> \c "Shape" The analytic expression of the RF pulse. See \ref ug_JEMRIS_seq_spec for explanation.
         	<li> \c "TPOIs" A number of time points at which the value is evaluated (but no signal acquired, as specified by the ADCs) 
         	<li> \c "Diff" If set to 1, then the actual pulse shape is defined by the first derivative of the analytic expression.
			In this case, the flip angle is set via the analytic expression rather than numerical integration.
         	<li> \c "Constants" A comma-sparated list of floating point numbers, which may be used as variables \c "c1,c2,..."
                                    in the Shape expression.
	 </ol>

	<li> <b> \c ExternalRFPulse</b>: An arbitrary RF pulse specified through an external binary file. It has all the attributes of the
		GaussianRFPulse, and additionally
	 <ol>
         	<li> \c "Filename" A simple binary file of doubles \f$(N,t_1,A_1,P_1,t_2,A_2,P_2,...,t_N,A_N,P_N)\f$ specifying the 
			time-points \f$t_i\f$, amplitudes \f$A_i\f$, and phases \f$P_i\f$, of the pulse.
         	<li> \c "Scale" An optional scale of the amplitudes (default 1)
	 </ol>
		Note, that such external binary files are easily constructed with the GUI: generate a global matlab variable
		of size \f$N \times 3\f$, where the first column are the time points and the remaining columns are
		RF amplitudes and phases. Then write the name of the variable to the attribute \c "Filename". The GUI will automatically
		construct the necessary binary file for JEMRIS.

</ul>

Note that in terms of numerical efficiency the built-in RF pulses (HardRFPulse,GaussianRFPulse,SincRFPulse) perform best, the
evaluation of an AnalyticRFPulse is slower, and an ExternalRFPulse is slowest, if it is specified through many data points.


Next, there exist several <b> Gradient Pulse Modules</b> in JEMRIS:

<ul> 
	<li> <b> \c TrapGradPulse</b>: A trapezoidal-shaped gradient pulse, which is the by far most used gradient
		pulse in JEMRIS. If no duration is specified, the pulse prepares in shortest possbile time according
		to the hardware limits.
		\image html doc/pics/ug_trapgrad.jpg
		\image latex doc/pics/ug_trapgrad.eps
		The TrapGradPulse has several attributes inherited from the basic GradientPulse class, i.e. these
		attributes are common for all gradient pulses:

 	<ol>
		<li> \c "Slewrate" and \c "MaxAmplitude": Hardware limits, specific only for the particular gradient.
			If not set, the limits from the \c Parameter module are used.
		<li> \c "Axis" The spatial axis of the gradient pulse; one of \c "GX", \c "GY", or \c "GZ".
		<li> \c "Area" The area of the pulse shape, i.e. the total k-space encoding.
		<li> \c "NLG_field" An optional attribute specifying an analytic expression for nonlinear gradients.
			See \ref ug_JEMRIS_seq_spec for explanation.
 	</ol>

		\n Further, the TrapGradPulse has attributes specific to its trapezoidal shape:

	 <ol>
         	<li> \c "FlatTopArea" Instead of specifying the area, only the area under the flat top may
			be specified.
         	<li> \c "FlatTopTime" Defines the duration of the flat top. 
			<b> In this case, ADCs are automatically set under the flat top (readout gradient).</b>
			Therefore, the \c "FlatTopTime" is in case of ADCs the reciprocal of the readout bandwidth.
         	<li> \c "Asymetric"   Ratio of the slew rates between the ramp up and the ramp down.
	 </ol>

		\n Finally, the TrapGradPulse has several hidden attributes which may provide important information to other
		modules: \c "Amplitude", \c "RampUpTime", \c "RampDnTime", "EndOfFlatTop". 

	<li> <b> \c SpiralGradientPulse</b>: A priliminary very simple spiral gradient, only intended for usage on 
                the \c "GX" and the \c "GY" axis. It has two attributes, \c "pitch" and \c "alpha" for scaling and
		spiral denisity, respecitvely. 

	<li> <b> \c AnalyticGradientPulse</b>: An arbitrary gradient pulse specified through an analytic expression.
		It has similar functionality as the AnalyticRFPulse. By setting the attribute \c "Diff=1", the attribute
		\c Shape directly allows specification of the k-space trajectory.

	<li> <b> \c ExternalGradientPulse</b>: An arbitrary Gradient pulse specified through an external binary file,
		again simliar to the denition of the ExternalRFPulse. Here, a binary file of doubles
		\f$(N,t_1,G_1,t_2,G_2,...,t_N,G_N)\f$ specify the time-points \f$t_i\f$ and gradient-values \f$G_i\f$ of the pulse.
		\n
		Note, that such external binary files are easily constructed by the GUI: generate a global matlab variable
		of size \f$N \times 2\f$, where the first column are the time points and the second column are the
		gradient values. Then write the name of the variable to the attribute \c "Filename". The GUI will automatically
		construct the necessary binary file for JEMRIS.
</ul>

\n

\section ug_JEMRIS_seq_ginac Analytical expressions
\subsection ug_JEMRIS_seq_ginac_obs The "Observe" Attribute
As mentioned above, instead of being numbers module attributes values can also be analytical expressions.
For that variables are needed which contain the attribute values of other modules.
Consider a gradient pulse with name "P1" which is dependent on the area of another gradient pulse "P2".
To have access to this value, the pulse "P1" needs the special attribute \c "Observe=P2,Area".
Now the area of pulse "P2" can be accessed in every attribute definition of "P1" with the variable \c "a1".
For instance, "P1" sets its area to minus half the area of "P2" through \c "Area=-0.5*a1".
Multiple attributes can be observed separated by a slash, e.g.: \c "Observe=P4,Area/P,Nx/P,Ny/C2,Repetitions" .
The observed attributes are then accessed with \c "a1", \c "a2", \c "a3", \c "a4", etc.

\subsection ug_JEMRIS_seq_ginac_hidden Hidden Attributes
Each module can have so-called hidden attributes which cannot be edited. Instead, these attributes are calculated from
supplied values at runtime. The ConcatSequence, for example, not only has the attribute \c "Repetitions", it also
has a hidden attribute \c "Counter" which gives the current loop-number. A hidden attribute can be observed by
other modules. A list of all hidden attributes can be displayed using the pull-down menu in each module. Some
frequently used hidden attributes are listed here: 

\li Parameters module:
\c "Dx", \c "Dy", \c  "Dz" (pixel size in image space); \c "DKx", \c  "DKy", \c  "DKz" (increment in k-space); \c "KMAXx", \c  "KMAXy", \c  "KMAXz" (boundaries of k-space).

\li ConcatSequence:
\c  "Counter" (loop counter); \c "Duration"

Hint: \c "Counter" is the most often observed attribute since it introduces the dynamic to the sequence. Attributes which observe a
loop counter change their value in run time. (If these attributes are further observed by other attributes, the latter of course will
also dynamically change their values accordingly.) 

\subsection ug_JEMRIS_seq_expressions Expression syntax and predefined functions
The symbolic expression syntax is similar to scalar computation syntax in Matlab. For instance, if a gradient observes three attributes,
then a valid formula for its area would be \c "Area=0.5*sqrt(a1)*sin(2*Pi*a2)*(-1)^a3"

Several predefined mathematical expressions may be used:
<TABLE>
	<TR> <TD> Pi		</TD> <TD> area of a unit circle</TD> </TR>
	<TR> <TD> abs(x)	</TD> <TD> absolute value	</TD> </TR>
	<TR> <TD> step(x)	</TD> <TD> step function	</TD> </TR>
	<TR> <TD> I		</TD> <TD> imaginary unit	</TD> </TR>
	<TR> <TD> csgn(x)	</TD> <TD> complex sign	</TD> </TR>
	<TR> <TD> conjugate(x)	</TD> <TD> complex conjugation	</TD> </TR>
	<TR> <TD> real_part(x)	</TD> <TD> real part	</TD> </TR>
	<TR> <TD> imag_part(x)	</TD> <TD> imaginary part	</TD> </TR>
	<TR> <TD> sqrt(x)	</TD> <TD> square root 	</TD> </TR>
	<TR> <TD> sin(x)	</TD> <TD> sine	</TD> </TR>
	<TR> <TD> cos(x)	</TD> <TD> cosine	</TD> </TR>
	<TR> <TD> tan(x)	</TD> <TD> tangent	</TD> </TR>
	<TR> <TD> asin(x)	</TD> <TD> inverse sine	</TD> </TR>
	<TR> <TD> acos(x)	</TD> <TD> inverse cosine	</TD> </TR>
	<TR> <TD> atan(x)	</TD> <TD> inverse tangent	</TD> </TR>
	<TR> <TD> atan2(y,x)	</TD> <TD> inverse tangent with two arguments	</TD> </TR>
	<TR> <TD> sinh(x) 	</TD> <TD> hyperbolic sine	</TD> </TR>
	<TR> <TD> cosh(x)	</TD> <TD> hyperbolic cosine	</TD> </TR>
	<TR> <TD> tanh(x) 	</TD> <TD> hyperbolic tangent	</TD> </TR>
	<TR> <TD> asinh(x)	</TD> <TD> inverse hyperbolic sine	</TD> </TR>
	<TR> <TD> acosh(x)	</TD> <TD> inverse hyperbolic cosine	</TD> </TR>
	<TR> <TD> atanh(x)	</TD> <TD> inverse hyperbolic tangent	</TD> </TR>
	<TR> <TD> exp(x)        </TD> <TD> exponential function	</TD> </TR>
	<TR> <TD> log(x)        </TD> <TD> natural logarithm 	</TD> </TR>
	<TR> <TD> floor(x)      </TD> <TD> round to integer	</TD> </TR>
	<TR> <TD> mod(x,y)      </TD> <TD> Modulo	</TD> </TR>
	<TR> <TD> equal(x,y)    </TD> <TD> returns 1, if x equals y, otherwise returns zero 	</TD> </TR>
	<TR> <TD> ite(x,y,a,b)  </TD> <TD> returns a, if x equals y, otherwise returns b 	</TD> </TR>
</TABLE>

There are further, less comonly used, mathematical functions. Please check the <a
href="http://www.ginac.de/tutorial"> GiNaC documentation </a>.


\subsection ug_JEMRIS_seq_spec Exceptional Attributes
Every Module has its attributes which will have its internal special meaning. However, for the observer mechanism all these
"standard attributes" may be arbitrarily linked to each other. For instance, the flip angle of an RF pulse may set its value
through observation of the area of a gradient. However, there are some exceptional attributes for which this general behaviour
does not work, i.e. these attributes can not be observed by other modules! These exceptions are listed below:

\li \c "Observe": Of course the Observe attribute itself can not be observed.

\li \c "Vector": Every pulse has the attribute \c "Vector". It is a space-separated list of floating point values which can be accessed by another attribute of this pulse. The values can be addressed by observation of loop counters, for instance an RF pulse may set \c "Observe=C1,Counter" and \c "FlipAnlge=Vector(a1)". Thus, the flip angle will loop through the vector as the loop-counter of the ConcatSequence increases. Note that in the Matlab GUI, \c "Vector" can also take any Matlab expression which results in a vector as input such as e.g. \c "rand(10,1)".

\li \c "Shape": For analytical RF / gradient pulses, this attribute defines the shape of the pulse using an analytical expression using the time variable \c "T". For RF-pulses, this expression can be complex to define the magnitude and phase of the RF-pulse. Use \c "I" as imaginary unit. The expression is again evaluated using GiNaC which is capable to perform derivatives. If here additionally the attribute \c "Diff=1" is set, the expression provided by the \c "Shape" attribute will be differentiated once, thus it is possible to directly provide the gradient moments.

\li \c "NLG_field": an analytical expression for non-linear gradient field can be specified to every gradient module. Use \c "R" as space variable, and \c "G" as gradient the value, e.g.  \c "NLG_field=R*G+0.001*R*G^2" will simulate a linear gradient field with a small quadratic term.

back to \ref toc.
***************************************************
*/

/**
***************************************************
* \page ug_JEMRIS_sim MRI %Simulator GUI JEMRIS_sim
To open the GUI to JEMRIS, open \c "JEMRIS_sim" as before in the path where the sequence *.xml files are stored. In the following screenshot, the epi-sequence has been loaded into the GUI and was simulated for a sphere sample:

\image html /doc/pics/epi_jemrissim_screenshot.jpg
\image latex /doc/pics/epi_jemrissim_screenshot.eps

Before the simulation, the sequence file has to be selected via "File->open Sequence". Next, the sample to which the sequence is applied has to be specified. There are three predefined samples: a sphere, two interleaved spheres and a brain model. Since 3D simulations are very time consuming, these samples are defined as 2D slices, while for the brain model the desired slice can be selected using \c "slice" parameter. For all samples, \c "{dx,dy}" specifies the distance between two neighboring spins. For larger distances, less spins need to be calculated and thus the simulation will be faster. However, artifacts are likely if too few spins are used in the simulation.

After specifying the sample and the sequence, the \c "start simu" button calls JEMRIS. Its output is displayed in the "simulation message dump". After the simulation has finished, the results will be displayed in the lower right of the GUI. Besides the signal, the k-space and the image space can be displayed. 

\section ug_JEMRIS_sim_add Additional parameters
On the right hand side there are four additional parameters which can be specified:

\li <b> "increment to store M(t)":</b> The signal is the sum over all simulated spins. However, the information of each individual spin is present in the simulation and can be returned by JEMRIS. If this parameter is set to i, the magnetization of each individual spin is stored for every i-th readout event.

\li <b>"random field fluctuations":</b> introduce static random field fluctuation which produce a \f$ T_2^* \f$.

\li <b>"concomitant fields":</b> account for concomitant fields introduced by the gradient field

\li <b>"random noise":</b> adds random noise to the signal data. This is done by the GUI itself, thus in contrast to the other three parameters the noise may be specified  \em after the simulation.

\section ug_JEMRIS_sim_par Parallelization
Since no interaction of the spins are considered, the MR simulation is an inherently parallel problem. Thus to speed up the calculation JEMRIS can make use of multiple CPUs, either of a computer cluster or of a multi-core processor on a single workstation. The desired mode can be selected from the "Settings" dialog. To utilize multiple CPU cores on a single workstation the GUI must be able to log into the system without supplying a password, thus an ssh-key has to be installed in the system (see \ref ug_install_key). 


back to \ref toc.
***************************************************
*/

/**
***************************************************
* \page ug_JEMRIS_tut %First steps tutorial

In this tutorial the user is introduced guided through the setup and
performance of an EPI experiment. This step by step introduction shall
enable the user to setup own experiments thereafter.

To proceed the user must have successfully compiled JEMRIS 2 as
described in the \ref ug_install section. 

\section ug_JEMRIS_episeq Setup the EPI sequence

\li Create a directory for your simulation experiments. This directory
will be called <b>\c work_dir</b> hereafter. 
\li Start up MATLAB
\li In MATLAB change directory to \c <b>work_dir</b>: <br/>
    <b> \c >> \c cd \c word_dir</b>
\li Add the path to the directory with the JEMRIS matlab code to your
MATLAB runtime
    <b> \c >> \c addpath \c ../jemris-2.0/app/matlab</b>
\li Start up the <b>Sequence GUI</b> with the following command<br>
    <b> \c >> \c JEMRIS_seq</b>
\image html /doc/pics/jemris_sequence.png
\image latex /doc/pics/jemris_sequence.png

We will now start to model an EPI sequence with the following
 protocol: TE 50ms, TR 100ms, FA 90, Imaging matrix 64x64, Maxmum
 gradient amplitude 40 mT/m, Maximum slewrate 200 mT/m, and FOV
 100x100.

\li From the File drop down menue choose "New sequence".
\li As <b>Filename</b> choose \c <b>MyEPI.xml</b> and save.

You will now see the minimum requirements for a sequence. The <b>top
 node</b> (outer most loop) of the sequence, \c <b>C1</b>, short
 ConcatSequence1 and the <b>paramters</b>, \c <b>P</b>. Let us start
 with the parameters. The <b>parameters</b> hold information valid for
 the whole sequence. These include in order from top left to bottom
 right: <b>name</b>, <b>FOV in x, y, and z direction</b>,<b>maximum
 gradient amplitude</b>, <b>maximum slewrate</b>, <b>TD</b>,
 <b>TE</b>, <b>TI</b>, and <b>TR</b>.

\li Set FOVx and FOVy to 100 each.
\li Set MaxGradAmpl to 40.
\li Set MaxSlewRate to 200.
\li Set Nx and Ny to 64 each.
\li Set TE to 50.
\li Set TR to 100.
\li Click on write XML.

Let us now model the sequence.

\li Click on the concat sequence \c <b>C1</b>
\li Set name to Sli for Slice loop.

Since we do not loop over more than one slices you do not need to
change any of the parameters of \c <b>Sli</b>.

We want to start with inserting the excitation Pulses. Pulses, which
are played out simultaneously are contained in <b>atomic
sequences</b>. 

\li Click in the selection bar on the symbol for atomic
sequences \c <b>A</b>.
\li Click on \c <b>Sli</b> and you will append.

An atomic sequence is appended to \c <b>Sli</b> by the name
of \c <b>A1</b>.

\li Change its name to \c <b>Exc</b> for excitation

Since we do not care for slice selection for this tutorial, we now
insert an hard RF pulse.

\li Click in the module bar on the symbol for the hard RF pulses.

When you hover over the fields a short description is shown for every
module.

\li Click on \c <b>Exc</b> to append the pulse to the excitation atomic
sequence. 
\li Change its name to \c <b>HRF</b> for hard RF pulse.
\li Set \c <b>FlipAngle</b> to 90 for 90 degrees.
\li Set \c <b>Duration</b> to 2 for 2ms.

The excitation is now sufficiently defined. We now need to insert
into the sequence the <b>dephasers</b> in read as well as PE
directions. For this purpose the next atom needs to be added after
the \c <b>Exc</b> atom. 

\li Select from the symbol bar the symbol for atomic sequences.
\li Click on \c <b>Sli</b> to insert the atom after \c <b>Exc</b>.
\li Change its name to \c <b>Dph</b> for dephasers.
\li Choose from the symbol bar the symbol for trapeziodal gradients.
\li Click on \c <b>Dph</b> to insert it therein.
\li Change its name to \c <b>Rdp</b> for read dephaser.
\li Repeat the last three steps for the phase encoding
dephaser. 
\li Change its name to \c <b>PDp</b>
\li Change its axis to \c <b>GY</b>

The areas for the dephasing gradients can not be set yet, since we
have to prepare the actual readout and phase encoding gradients first.
But first we need to introduct a dead time to match the center of the
EPI readout with \c <b>TE</b> from the parameters.

\li Choose the symbol for a delay atomic sequence from the module bar.
\li Click on \c <b>Sli</b> to add it to the sequence.

You will find details on delays here: \ref
ug_JEMRIS_seq_intro_seqmod. Once again the delay cannot be complete
entirely besides that we know that \c <b>TE</b> starts at the centre of
the excitation and ends at the centre of the EPI
readout. 

One could now type in the value for TE in \c <b>Duration</b>. But a
very convenient feature of JEMRIS helps us minimize the effort for
future changes to our sequence such as changes to TE. Namely that
every module is able to <b>observe</b> values in other modules of the
sequence; may they be dynamically changing over the duration of the
sequence or static.

We would like to observe \c <b>TE</b> from \c <b>P</b>. We inform \c
<b>DTE</b> in the following manner:

\li Set \c <b>Observe</b> to  <b>\c P,\c TE</b>

Now we can use this new <b>attribute</b> known to the module as \c <b>a1</b>

\li Set the \c <b>Duration</b> to  <b>\c a1</b>.

Let us now insert and compose the EPI readout. For this, we would like
to implement a loop structure for one readout line and one phase
encoding blip to run through all phase encoding steps.

\li Click on the symbol of a contact sequence in the module bar.
\li Change its name to <b>\c ERL</b> for EPI readout loop.
\li Set <b>\c Observe</b> to <b>\c P,Ny</b>.
\li Set <b>\c Repetitions</b> to <b>\c a1</b>
\li Add two atomic sequence to <b>\c ERL</b> to <b>\c ERL</b> and change their
names to <b>\c ROA</b> and <b>\c PEA</b> for readout atom and phase
encoding atom.
\li Add to each one trapezoidal gradient and change their names to
<b>\c ROG</b> and <b>\c PEG</b> and their <b>\c Axes</b> to <b>\c
GX</b> and <b>\c GY</b> respectively.

We have to define the FlatTopArea and the number of sampling points on
the flat top of <b>\c ROG</b>. The latter is rather
straightforward. We need to <b>observe</b> the imaging matrix size
defined in <b>\c P</b>. 

\li Set <b>\c Observe</b> to <b>\c P,Nx</b>.

This is the first attribute and known to <b>\c ROG</b>, according to
above, as <b>\c a1</b>.

\li Set <b>\c ADCs</b> to <b>\c a1</b>.

For defining the flat top of <b>\c ROG</b> we have to know the maximum
k-space vector in readout direction and the number of the line, which
is acquired. We introduce these two attributes to <b>\c
Observe</b>. Observed values are seperated by <b>\c /</b> (slash).

\li Append to <b>\c Observe</b> the following string: <b>\c
"P,KMAXx/ERL,Counter"</b>

<b>\c ROG</b> now knows the two new attributes as <b>\c a2</b> an
<b>\c a3</b>. The <b>\c FlatTopArea</b> then should change the polarity for
every second line and go from <b>\c -KMAXx</b> to <b>\c +KMAXx</b>.

\li Set <b>\c FlatTopArea</b> to<b>\c 2*a2*(-1)^a3</b>.
\li Set <b>\c FlatTopTime</b> to <b>\c 1</b>.

Here the integrated library for symbolic mathematics, GiNAC helps us
to calculate the <b>\c FlatTopArea</b> by the evaluation of a real
formula.

Let us define the <b>\c Area</b> of the PE blips. This is a very
simple assignement. The area will be the size of the phase encoding
steps in <b>\c Ky</b> direction.

\li Set <b>\c Observe</b> to <b>\c P,DKy</b>.
\li Set <b>\c Area</b> of <b>\c PEG</b> equal <b>\c -a1</b>.

Now that <b>\c ROG</b> and <b>\c PEG </b>are defined we can go back and
define the missing parameters of <b>\c RDp</b> and <b>\c PDp</b>. <b>\c RDp</b>
should send the magnetisation to <b>\c -KMAXx</b> and <b>\c PDp</b> to
the top edge of the K-space (<b>\c KMAXy</b>).

\li Set <b>\c Observe</b> of <b>\c RDp</b> to <b>\c P,KMAXx</b>.
\li Set <b>\c Area</b> of <b>\c RDp</b> to <b>\c -a1</b>.
\li Set <b>\c Observe</b> of <b>\c PDp</b> to <b>\c P,KMAXy</b>.
\li Set <b>\c Area</b> of <b>\c PDp</b> to <b>\c a1</b>.

Let us now define the missing parameters of the delay <b>\c DTE</b>. 

\li Set the <b>\c DelayType</b> to <b>\c C2C</b>.
\li Set <b>\c Observe</b> to <b>\c P,TE</b>.
\li Set <b>\c Delay</b> to <b>\c a1</b>.
\li Set <b>\c StartSeq</b> to <b>\c HRF</b>.
\li Set <b>\c StopSeq</b> to <b>\c REL</b>.

The only missing element is now the constraints associated with TR. So
will add a delay to the end of the sequence to suffice those
constraints.

\li Choose from the module bar the symbol for an DelayAtomicSequence.
\li Click on <b>\c Sli</b> to append it to the sequence.
\li Set <b>\c Name</b> to <b>\c DTR</b>
\li Set <b>\c DelayTape</b> to <b>\c B2E</b>.
\li Set <b>\c Observe</b> to <b>\c P,TR</b>.
\li Set <b>\c Delay</b> to <b>\c a1</b>.
\li Set <b>\c StartSeq</b> to <b>\c Sli</b>.

We are done now with the EPI sequence. 

\section ug_JEMRIS_episim Simulate the sequence


back to \ref toc.
***************************************************
*/


