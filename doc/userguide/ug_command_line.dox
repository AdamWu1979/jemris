/**
***************************************************
* \page ug_command_line Running JEMRIS from the Command Line
The above introduced Matlab GUIs follow the same procedure: construct a valid XML file from the user input, then call the external JEMRIS
executables to compute the data, and finally read and visualise the result. Of course it is possible to directly run
the executables without running Matlab. For this, the XML configuration files might be directly manipulated to set up
the numerical experiments.

This section presents example XML files and explains how to start the simulation from the command line:
\n

\li \ref ug_command_line_XML

\li \ref ug_command_line_jemris

\li \ref ug_command_line_pjemris
\n
 <HR>

\section ug_command_line_XML Creating and editing XML configuration Files
There are three different types of XML files which configure a JEMRIS simulation:
\li \ref ug_seq_xml
\li \ref ug_trx_xml
\li \ref ug_sim_xml

\subsection ug_seq_xml The Sequence XML file

MRI sequences may be scripted directly in XML where the sequence and pulse modules are represented
by XML elements. Their parameterization is done via attributes utilizing the observer
mechanism. See section \ref ug_JEMRIS_seq_modules for a list of available modules and their attributes. Section
\ref ug_JEMRIS_seq_ginac describes the observer mechanism and symbolic attribute dependences. 

This is an example of a 2D EPI sequence for 2D simulation (i.e. without slice selection). \n
\code
<?xml version="1.0" encoding="utf-8"?>
<Parameters FOVx="256" FOVy="256" GradMaxAmpl="2" GradSlewRate="10" Name="P" Nx="64" Ny="64" TE="50" TR="100">
   <ConcatSequence Name="C1">
      <AtomicSequence Name="A1">
         <HARDRFPULSE Axis="RF" Duration="0.1" FlipAngle="90" Name="P1"/>
      </AtomicSequence>
      <AtomicSequence Name="A2">
         <TrapGradPulse Area="0.5*a1" Axis="GX" Name="P2" Observe="P4,Area"/>
         <TrapGradPulse Area="a1" Axis="GY" Name="P3" Observe="P,KMAXy"/>
      </AtomicSequence>
      <DelayAtomicSequence Delay="a1" DelayType="C2C" Name="D1" Observe="P,TE" StartSeq="A1" StopSeq="C2"/>
      <ConcatSequence Name="C2" Observe="P,Ny" Repetitions="a1">
         <AtomicSequence Name="A3">
            <TrapGradPulse Name="P4" Axis="GX" FlatTopArea="2*a1*(-1)^a2" FlatTopTime="1"
                           ADCs="a3" Observe="P,KMAXx/C2,Counter/P,Nx"/>
         </AtomicSequence>
         <AtomicSequence Name="A4">
            <TrapGradPulse Area="-a1" Axis="GY" Name="P5" Observe="P,DKy/C2,Counter/C2,Repetitions"/>
         </AtomicSequence>
      </ConcatSequence>
      <DelayAtomicSequence Delay="a1" DelayType="B2E" Name="D2" Observe="P,TR" StartSeq="A1"/>
   </ConcatSequence>
</Parameters>
\endcode
\n

\subsection ug_trx_xml The Coil Array XML file
As for the sequence, also coil array files can be directly scripted in XML. Elements represent the available coils (see section '\ref ug_JEMRIS_txrx' for a complete list and
their parameterization).
This is an example for an 8 channel phased array:
\code

<?xml version="1.0" encoding="utf-8"?>
<CoilArray>
   <BIOTSAVARTLOOP Azimuth="0" Dim="3" Extent="260" Name="C1" Points="32" Polar="90" Radius="200" Scale="0.19" XPos="256" YPos="0" ZPos="0"/>
   <BIOTSAVARTLOOP Azimuth="45" Dim="3" Extent="260" Name="C2" Points="32" Polar="90" Radius="200" Scale="0.19" XPos="181.019" YPos="181.019" ZPos="0"/>
   <BIOTSAVARTLOOP Azimuth="90" Dim="3" Extent="260" Name="C3" Points="32" Polar="90" Radius="200" Scale="0.19" XPos="0" YPos="256" ZPos="0"/>
   <BIOTSAVARTLOOP Azimuth="135" Dim="3" Extent="260" Name="C4" Points="32" Polar="90" Radius="200" Scale="0.19" XPos="-181.019" YPos="181.019" ZPos="0"/>
   <BIOTSAVARTLOOP Azimuth="180" Dim="3" Extent="260" Name="C5" Points="32" Polar="90" Radius="200" Scale="0.19" XPos="-256" YPos="0" ZPos="0"/>
   <BIOTSAVARTLOOP Azimuth="225" Dim="3" Extent="260" Name="C6" Points="32" Polar="90" Radius="200" Scale="0.19" XPos="-181.019" YPos="-181.019" ZPos="0"/>
   <BIOTSAVARTLOOP Azimuth="270" Dim="3" Extent="260" Name="C7" Points="32" Polar="90" Radius="200" Scale="0.19" XPos="0" YPos="-256" ZPos="0"/>
   <BIOTSAVARTLOOP Azimuth="315" Dim="3" Extent="260" Name="C8" Points="32" Polar="90" Radius="200" Scale="0.19" XPos="181.019" YPos="-181.019" ZPos="0"/>
</CoilArray>
\endcode
\n

\subsection ug_sim_xml The Simulation XML file
The simulation XML file contains elements for the XML file locations of the sequence, the coil arrays (transmit and receive), and the location of the sample binary file (the object).\n
Examples of such samples as well as how to create user defined samples are described in section \ref ug_JEMRIS_sim_sample.

Additionally, a few other parameters may be added via attributes of the "parameter" element which are documented in section '\ref ug_JEMRIS_sim_add' of the simulation GUI chapter.

This is an example for a simulation XML file generated by the \ref ug_JEMRIS_sim :
\code
<?xml version="1.0" encoding="utf-8"?>
<simulate name="JEMRIS">
   <sequence name="epi" uri="/data/mr_cluster/tstoecker/example/epi.xml"/>
   <sample name="brain" uri="/data/mr_cluster/tstoecker/example/sample.bin"/>
   <RXcoilarray uri="/usr/local/share/jemris/matlab/uniform.xml"/>
   <TXcoilarray uri="/usr/local/share/jemris/matlab/uniform.xml"/>
   <parameter ConcomitantFields="0" EvolutionPrefix="evol" EvolutionSteps="0" RandomNoise="0"/>
   <model name="Bloch" type="CVODE"/>
</simulate>
\endcode
\n

 <HR>
\section ug_command_line_jemris Invoking the JEMRIS executable
Executing jemris on the command line without arguments shows the possible options:
\code
me@my_box:~$ jemris

JEMRIS 2.2 r1480M

jemris usage

       1. jemris <xml-file>
       The file could be either a a) Simulation, b) Sequence, or c) Coilarray file,
       so that a) the simulation is performed, b) a sequence diagram is written,
       or c) the sensitivity maps are dumped, respectively.

       2. jemris modlist
       Writes the file mod.xml containing a list of all available modules.
\endcode
The special case 'modlist' is used by the \ref ug_JEMRIS_seq to generate
the list of modules. Therefore, framework extensions will automatically appear in the GUI. 

\n
\subsection ug_command_line_jemris_seq Generating the Pulse Sequence Diagram Data

Running jemris with the EPI sequence XML file results in
\code
me@my_box:~$ jemris /usr/local/share/jemris/examples/epi.xml

JEMRIS 2.2 r1480M

dump of sequence tree
                          TYPE              CLASS        NAME  duration      ADCs     TPOIs |  module specific
                          ----------------------------------------------------------------- |  ---------------
sequence-root-------->   CONCAT       CONCATSEQUENCE       C1   100.000     4096      4488  |  Repetitions = 1
  |_ child 1   ------>     ATOM       ATOMICSEQUENCE       A1     0.100        0         1  |
    |_ child 1   ---->    PULSE          HARDRFPULSE       P1     0.100        0         1  |  Axis = RF  , (Flipangle,Phase,Bandwidth,Channel) = (90,0,1e+16,0)
  |_ child 2   ------>     ATOM       ATOMICSEQUENCE       A2     0.654        0         5  |
    |_ child 1   ---->    PULSE        TRAPGRADPULSE       P2     0.654        0         3  |  Axis = GX  , Area = -0.908768
    |_ child 2   ---->    PULSE        TRAPGRADPULSE       P3     0.593        0         3  |  Axis = GY  , Area = 0.785398
  |_ child 3   ------>     ATOM  DELAYATOMICSEQUENCE       D1     4.072        0         1  |  DelayType = C2C  , StartSeq = A1 , StopSeq = C2
    |_ child 1   ---->    PULSE           EMPTYPULSE    eP_D1     4.072        0         1  |  Axis = none
  |_ child 4   ------>   CONCAT       CONCATSEQUENCE       C2    90.448     4096      4480  |  Repetitions = 64
    |_ child 1   ---->     ATOM       ATOMICSEQUENCE       A3     1.314       64        68  |
      |_ child 1   -->    PULSE        TRAPGRADPULSE       P4     1.314       64        68  |  Axis = GX  , Area = -1.81754 , FlatTop: (Area,time)= (-1.5708,1)
    |_ child 2   ---->     ATOM       ATOMICSEQUENCE       A4     0.099        0         2  |
      |_ child 1   -->    PULSE        TRAPGRADPULSE       P5     0.099        0         3  |  Axis = GY  , Area = -0.0245437
  |_ child 5   ------>     ATOM  DELAYATOMICSEQUENCE       D2     4.726        0         1  |  DelayType = B2E  , StartSeq = A1
    |_ child 1   ---->    PULSE           EMPTYPULSE    eP_D2     4.726        0         1  |  Axis = none

\endcode
Additionally, a binary file "seq.bin" is written which is read by the Matlab GUI to plot the sequence diagram.

The output shows that this sequence has in total 4096 ADC points. The sequence diagram is non-equidistantly sampled: it consists of 4488 TPOIs ("time points of interest")
which are the ADCs plus some additional important time points (for instance the ramps of trapezoidal gradients).
In the above example the binary file "seq.bin" contains 4888 sampling points.
The information is stored in 7-tuple [time, receiver phase, RF magnitude, RF phase, X Gradient, Y Gradient, Z Gradient] without header information.

To read the sequence diagram binary file in Matlab:
\code
 f=fopen('seq.bin');
 A=fread(f,Inf,'double');
 fclose(f);
 N              = length(A)/7;     % the number of TPOIs
 A              = reshape(A,7,N);  % the sequence diagram in an 7 times N matrix 
 time_axis      = A(1,:);          % 1st row: temporal sampling points 
 receiver_phase = A(2,:);          % 2nd row: Receiver phase; unit: radiants; if negative, the TPOI was not an ADC
 RF_magnitude   = A(3,:);          % 3rd row: RF pulse magnitude
 RF_phase       = A(4,:);          % 4th row: RF pulse phase; unit: radiants
 Grad_x         = A(5,:);          % 5th row: physical X-Gradient
 Grad_y         = A(6,:);          % 6th row: physical Y-Gradient
 Grad_z         = A(7,:);          % 7th row: physical Z-Gradient
\endcode

\n
\subsection ug_command_line_jemris_sense Generating the Coil Sensitivity Maps

Running jemris with a coil array XML file results in
\code
me@my_box:~$ jemris /usr/local/share/jemris/examples/8chheadcyl.xml 

JEMRIS 2.2 r1509M

dumping sensitivity maps ...
Channel #0: Coil C1 (BIOTSAVARTLOOP):  dumps to RXsensmap01.bin
Channel #1: Coil C2 (BIOTSAVARTLOOP):  dumps to RXsensmap02.bin
Channel #2: Coil C3 (BIOTSAVARTLOOP):  dumps to RXsensmap03.bin
Channel #3: Coil C4 (BIOTSAVARTLOOP):  dumps to RXsensmap04.bin
Channel #4: Coil C5 (BIOTSAVARTLOOP):  dumps to RXsensmap05.bin
Channel #5: Coil C6 (BIOTSAVARTLOOP):  dumps to RXsensmap06.bin
Channel #6: Coil C7 (BIOTSAVARTLOOP):  dumps to RXsensmap07.bin
Channel #7: Coil C8 (BIOTSAVARTLOOP):  dumps to RXsensmap08.bin
\endcode

The coil sensitivity binary files contain [magnitude,phase]  in column major order for each
point on the grid (which is specified in the XML file).

\n
\subsection ug_command_line_jemris_sim Executing MRI Simulations

Running jemris with a simulation XML file
\code
me@my_box:~$ jemris /usr/local/share/jemris/examples/8chheadcyl.xml 
jemris simu.xml 

JEMRIS 2.2 r1509M

Model    : Bloch          , solver = CVODE
Sample   : 2D sphere      , spins  = 7825
TxArray  : /usr/local/share/jemris/matlab/uniform.xml
RxArray  : /usr/local/share/jemris/matlab/uniform.xml
Sequence : /data/mr_cluster/tstoecker/jemris_paper_ex/epi.xml


 simulating ...
Finished ! 
\endcode
The simulation result is stored to binary file "signal01.bin". In case of receiver coil array, additional binary files "signal02.bin", "signal03.bin", etc. for each receiver channel.

The MRI signal binary files contain the net magnetisation in 4-tuple [time,Mx,My,Mz] at each ADC event of the sequence.

\n
\n

 <HR>
\section ug_command_line_pjemris Invoking the parallel version of JEMRIS
Running the parallel version requires a working MPI environment (see \ref ug_install).

The following command runs the parallel version with 5 parallel processes:
\code
me@my_box:~$ mpirun -np 5 pjemris simu.xml


PARALLEL JEMRIS 2.2 r1470M

Model    : Bloch	  , solver = CVODE
Sample   : brain	  , spins  = 25841
TxArray  : /usr/local/share/jemris/matlab/uniform.xml
RxArray  : /usr/local/share/jemris/matlab/uniform.xml
Sequence : /data/mr_cluster/tstoecker/example/epi.xml

nmrpc40 -> Master Process: send MR sample (25841 spins) to 4 slave(s)

nmrpc40 -> slave  1:  received 10 spins for simulation ...
nmrpc40 -> slave  4:  received 40 spins for simulation ...
nmrpc40 -> slave  2:  received 20 spins for simulation ...
nmrpc40 -> slave  3:  received 30 spins for simulation ...
nmrpc40 -> slave  1:  received 1016 spins for simulation ...
nmrpc40 -> slave  2:  received 952 spins for simulation ...
nmrpc40 -> slave  4:  received 1014 spins for simulation ...
nmrpc40 -> slave  3:  received 728 spins for simulation ...
 [ .
   .
   . ]

MPI Process Wtime = 208.64 seconds
Finished
\endcode
The resulting signal binary files are the same as for sequential jemris simulations.

Additionally, the percent progress is written to the hidden file ".jemris_progress.out".

Note that spins are first distributed in small packets, then the packet size increases (and decreases at the end, to ).
The program performs load balancing and first estimates the number of spins which are simulated in 5 seconds per process. Then,
every 5 seconds checkpoints are stored to temporary hidden binary files the ".spins_state.dat" and ".tmp_sig01.bin" which are removed
after successful completion. If however the simulation is unexpectedly stopped, a restart will continue at the last checkpoint.
This is useful for huge simulations lasting several hours (or even days) where sudden crash e.g. due to power breakdown may occur.

back to \ref toc.
*/
